name: PR Auto Merge Test

on:
  workflow_dispatch:
  schedule:
    - cron: '*/5 * * * *'

permissions:
  pull-requests: write
  contents: write
  checks: read
  statuses: read

jobs:
  auto-merge:
    runs-on: ubuntu-latest

    steps:
    - name: Auto Merge PRs with label "auto-merge"
      uses: actions/github-script@v7
      with:
        script: |
          console.log("üîç Starting auto-merge test check...");
          console.log(`Event: ${context.eventName}`);
          console.log(`Repo: ${context.repo.owner}/${context.repo.repo}`);

          const { data: prList } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });

          console.log(`üìã Total open PRs: ${prList.length}`);

          const prs = prList.filter(pr => 
            pr.labels.some(label => label.name === 'auto-merge') &&
            pr.base.ref === 'main' &&
            !pr.draft
          );

          console.log(`üéØ Found ${prs.length} open PR(s) with 'auto-merge' label targeting main`);

          if (prs.length === 0) {
            console.log("‚ÑπÔ∏è No PRs found with auto-merge label. Create a PR with 'auto-merge' label to test.");
            return;
          }

          for (const pr of prs) {
            console.log(`\nüîÑ Checking PR #${pr.number}: ${pr.title}`);
            console.log(`  - Author: ${pr.user.login}`);
            console.log(`  - Branch: ${pr.head.ref} -> ${pr.base.ref}`);
            console.log(`  - Draft: ${pr.draft}`);
            console.log(`  - Mergeable: ${pr.mergeable}`);

            // Get all checks for this PR
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });

            const allChecksPassed = checks.check_runs.length === 0 || checks.check_runs.every(check =>
              check.status === 'completed' &&
              (check.conclusion === 'success' || check.conclusion === 'neutral')
            );

            console.log(`  - Check runs: ${checks.check_runs.length}`);
            console.log(`  - All checks passed: ${allChecksPassed}`);

            // Get status checks
            let allStatusesPassed = true;
            try {
              const { data: statuses } = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              allStatusesPassed = statuses.state === 'success' || statuses.statuses.length === 0;
              console.log(`  - Status state: ${statuses.state}`);
            } catch (error) {
              console.log(`  - Status checks not accessible, skipping status validation`);
            }

            // Check if ready to merge
            const checksReady = allChecksPassed && allStatusesPassed;
            const notBlocked = pr.mergeable !== false; // Allow null (calculating) and true
            const readyToMerge = checksReady && notBlocked;

            console.log(`  - Checks ready: ${checksReady}`);
            console.log(`  - Not blocked: ${notBlocked}`);
            console.log(`  - Ready to merge: ${readyToMerge}`);

            if (readyToMerge) {
              try {
                console.log(`üöÄ Attempting to merge PR #${pr.number}...`);
                
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  commit_title: `${pr.title} (#${pr.number})`,
                  merge_method: 'squash'
                });

                console.log(`‚úÖ PR #${pr.number} merged successfully`);

                // Delete branch
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${pr.head.ref}`
                  });
                  console.log(`üóëÔ∏è Branch ${pr.head.ref} deleted`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è Could not delete branch: ${error.message}`);
                }

              } catch (error) {
                console.log(`‚ùå Failed to merge PR #${pr.number}: ${error.message}`);
                
                // Log more details about the error
                if (error.status === 405) {
                  console.log(`   Reason: PR is not in a mergeable state`);
                } else if (error.status === 409) {
                  console.log(`   Reason: Merge conflict or head branch was modified`);
                } else {
                  console.log(`   Status: ${error.status}`);
                  console.log(`   Details: ${JSON.stringify(error.response?.data, null, 2)}`);
                }
              }
            } else {
              console.log(`‚è≥ PR #${pr.number} not ready for auto-merge`);
              if (!allChecksPassed) {
                console.log(`   - Some checks are failing or pending`);
              }
              if (!allStatusesPassed) {
                console.log(`   - Some status checks are failing`);
              }
              if (pr.mergeable === false) {
                console.log(`   - PR has merge conflicts or is blocked`);
              }
            }
          }

          console.log("\nüèÅ Auto-merge test completed");
